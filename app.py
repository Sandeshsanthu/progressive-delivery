# Code Generated by Sidekick is for learning and experimentation purposes only.
from __future__ import annotations

import os
import re
import sqlite3
from datetime import datetime, timezone
from functools import wraps

from flask import (
    Flask, g, render_template, request, redirect, url_for, session, flash, abort
)
from werkzeug.security import generate_password_hash, check_password_hash
from feature_flags import init_unleash, flag

APP_DIR = os.path.abspath(os.path.dirname(__file__))
DB_PATH = os.environ.get("DB_PATH", os.path.join(APP_DIR, "car_market.db"))

app = Flask(__name__)
app.config["SECRET_KEY"] = os.environ.get("SECRET_KEY", "dev-only-change-me")  # set env var in real use


# ----------------------------
# Database helpers
# ----------------------------
def get_db() -> sqlite3.Connection:
    if "db" not in g:
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = sqlite3.Row
        conn.execute("PRAGMA foreign_keys = ON;")
        g.db = conn
    return g.db

def money_to_cents(value) -> int:
    return int(round(float(value) * 100))
init_unleash()

@app.teardown_appcontext
def close_db(_exc):
    db = g.pop("db", None)
    if db is not None:
        db.close()


def init_db():
    db = get_db()

    db.execute(
        """
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT NOT NULL UNIQUE,
            password_hash TEXT NOT NULL,
            created_at TEXT NOT NULL
        );
        """
    )

    db.execute(
        """
        CREATE TABLE IF NOT EXISTS listings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            title TEXT NOT NULL,
            make TEXT NOT NULL,
            model TEXT NOT NULL,
            year INTEGER NOT NULL,
            mileage INTEGER NOT NULL,
            price_cents INTEGER NOT NULL,
            currency TEXT NOT NULL DEFAULT 'USD',
            location TEXT NOT NULL,
            description TEXT NOT NULL,
            status TEXT NOT NULL DEFAULT 'ACTIVE',  -- ACTIVE or SOLD
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        );
        """
    )

    db.execute("CREATE INDEX IF NOT EXISTS idx_listings_status_created ON listings(status, created_at);")
    db.execute("CREATE INDEX IF NOT EXISTS idx_listings_user ON listings(user_id, created_at);")

    db.commit()


@app.before_request
def _ensure_db():
    init_db()


# ----------------------------
# Auth utilities
# ----------------------------
def login_required(view):
    @wraps(view)
    def wrapped(*args, **kwargs):
        if "user_id" not in session:
            flash("Please log in to continue.", "warning")
            return redirect(url_for("login", next=request.path))
        return view(*args, **kwargs)
    return wrapped


def current_user():
    uid = session.get("user_id")
    if not uid:
        return None
    db = get_db()
    return db.execute("SELECT id, name, email FROM users WHERE id = ?", (uid,)).fetchone()


@app.context_processor
def inject_user():
    return {"current_user": current_user()}


# ----------------------------
# Validation helpers
# ----------------------------
EMAIL_RE = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")


def utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="seconds")


def parse_int(value: str, field: str, min_v: int | None = None, max_v: int | None = None) -> int:
    try:
        n = int(value)
    except Exception:
        raise ValueError(f"{field} must be a whole number.")
    if min_v is not None and n < min_v:
        raise ValueError(f"{field} must be at least {min_v}.")
    if max_v is not None and n > max_v:
        raise ValueError(f"{field} must be at most {max_v}.")
    return n


def parse_price_to_cents(value: str) -> int:
    """
    Accepts: "12000", "12000.50", "12,000.50"
    Returns integer cents.
    """
    v = value.strip().replace(",", "")
    if not re.fullmatch(r"\d+(\.\d{1,2})?", v):
        raise ValueError("Price must be a number like 12000 or 12000.50.")
    if "." in v:
        dollars, cents = v.split(".")
        cents = (cents + "0")[:2]
    else:
        dollars, cents = v, "00"
    price_cents = int(dollars) * 100 + int(cents)
    if price_cents <= 0:
        raise ValueError("Price must be greater than 0.")
    if price_cents > 500_000_000 * 100:  # sanity cap: $500M
        raise ValueError("Price looks too large.")
    return price_cents


def money_display(price_cents: int, currency: str = "USD") -> str:
    return f"{currency} {price_cents/100:,.2f}"


@app.template_filter("money")
def _money_filter(price_cents):
    return money_display(int(price_cents))


# ----------------------------
# Routes: Public
# ----------------------------
@app.get("/")
def index():
    db = get_db()
    q = (request.args.get("q") or "").strip()
    make = (request.args.get("make") or "").strip()
    min_year = (request.args.get("min_year") or "").strip()
    max_price = (request.args.get("max_price") or "").strip()

    where = ["l.status = 'ACTIVE'"]
    params = []

    if q:
        where.append("(l.title LIKE ? OR l.description LIKE ? OR l.model LIKE ? OR l.make LIKE ? OR l.location LIKE ?)")
        like = f"%{q}%"
        params += [like, like, like, like, like]

    if make:
        where.append("l.make LIKE ?")
        params.append(f"%{make}%")

    if min_year:
        try:
            y = parse_int(min_year, "Min year", 1900, datetime.now().year + 1)
            where.append("l.year >= ?")
            params.append(y)
        except ValueError as e:
            flash(str(e), "warning")

    if max_price:
        try:
            max_cents = parse_price_to_cents(max_price)
            where.append("l.price_cents <= ?")
            params.append(max_cents)
        except ValueError as e:
            flash(str(e), "warning")

    sql = f"""
        SELECT l.*, u.name AS seller_name
        FROM listings l
        JOIN users u ON u.id = l.user_id
        WHERE {' AND '.join(where)}
        ORDER BY l.created_at DESC
        LIMIT 50;
    """
    listings = db.execute(sql, params).fetchall()
    return render_template("index.html", listings=listings, q=q, make=make, min_year=min_year, max_price=max_price)


@app.get("/listing/<int:listing_id>")
def listing_detail(listing_id: int):
    db = get_db()
    listing = db.execute(
        """
        SELECT l.*, u.name AS seller_name, u.email AS seller_email
        FROM listings l
        JOIN users u ON u.id = l.user_id
        WHERE l.id = ?
        """,
        (listing_id,),
    ).fetchone()
    if not listing:
        abort(404)

    # If SOLD, still viewable (common marketplace behavior).
    return render_template("listing_detail.html", listing=listing)


# ----------------------------
# Routes: Auth
# ----------------------------
@app.get("/register")
def register():
    return render_template("register.html")


@app.post("/register")
def register_post():
    name = (request.form.get("name") or "").strip()
    email = (request.form.get("email") or "").strip().lower()
    password = request.form.get("password") or ""

    # Conditions / validation
    if len(name) < 2:
        flash("Name must be at least 2 characters.", "danger")
        return redirect(url_for("register"))
    if not EMAIL_RE.match(email):
        flash("Please enter a valid email.", "danger")
        return redirect(url_for("register"))
    if len(password) < 8:
        flash("Password must be at least 8 characters.", "danger")
        return redirect(url_for("register"))

    db = get_db()
    try:
        db.execute(
            "INSERT INTO users (name, email, password_hash, created_at) VALUES (?, ?, ?, ?)",
            (name, email, generate_password_hash(password), utc_now_iso()),
        )
        db.commit()
    except sqlite3.IntegrityError:
        flash("That email is already registered. Please log in.", "warning")
        return redirect(url_for("login"))

    flash("Account created. Please log in.", "success")
    return redirect(url_for("login"))


@app.get("/login")
def login():
    return render_template("login.html", next=request.args.get("next") or "")


@app.post("/login")
def login_post():
    email = (request.form.get("email") or "").strip().lower()
    password = request.form.get("password") or ""
    next_url = (request.form.get("next") or "").strip() or url_for("index")

    db = get_db()
    user = db.execute("SELECT * FROM users WHERE email = ?", (email,)).fetchone()
    if not user or not check_password_hash(user["password_hash"], password):
        flash("Invalid email or password.", "danger")
        return redirect(url_for("login", next=next_url))

    session.clear()
    session["user_id"] = int(user["id"])
    flash(f"Welcome back, {user['name']}!", "success")
    return redirect(next_url)


@app.post("/logout")
@login_required
def logout():
    session.clear()
    flash("You have been logged out.", "info")
    return redirect(url_for("index"))


# ----------------------------
# Routes: Listings (seller actions)
# ----------------------------
@app.get("/listings/new")
@login_required
def new_listing():
    return render_template("new_listing.html")


@app.post("/listings/new")
@login_required
def new_listing_post():
    user = current_user()
    assert user is not None

    # Read fields
    title = (request.form.get("title") or "").strip()
    make = (request.form.get("make") or "").strip()
    model = (request.form.get("model") or "").strip()
    year_s = (request.form.get("year") or "").strip()
    mileage_s = (request.form.get("mileage") or "").strip()
    price_s = (request.form.get("price") or "").strip()
    location = (request.form.get("location") or "").strip()
    description = (request.form.get("description") or "").strip()

    # Conditions / validation (typical marketplace rules)
    errors = []
    if len(title) < 5:
        errors.append("Title must be at least 5 characters.")
    if not make:
        errors.append("Make is required.")
    if not model:
        errors.append("Model is required.")
    if len(location) < 2:
        errors.append("Location is required.")
    if len(description) < 20:
        errors.append("Description must be at least 20 characters (add details).")

    try:
        year = parse_int(year_s, "Year", 1900, datetime.now().year + 1)
    except ValueError as e:
        errors.append(str(e))
        year = 2000

    try:
        mileage = parse_int(mileage_s, "Mileage", 0, 2_000_000)
    except ValueError as e:
        errors.append(str(e))
        mileage = 0

    try:
        price_cents = parse_price_to_cents(price_s)
    except ValueError as e:
        errors.append(str(e))
        price_cents = 0

    if errors:
        for e in errors:
            flash(e, "danger")
        return redirect(url_for("new_listing"))

    now = utc_now_iso()
    db = get_db()
    db.execute(
        """
        INSERT INTO listings
          (user_id, title, make, model, year, mileage, price_cents, currency, location, description, status, created_at, updated_at)
        VALUES
          (?, ?, ?, ?, ?, ?, ?, 'USD', ?, ?, 'ACTIVE', ?, ?)
        """,
        (int(user["id"]), title, make, model, year, mileage, price_cents, location, description, now, now),
    )
    db.commit()

    flash("Your car has been posted and is now visible to buyers.", "success")
    return redirect(url_for("my_listings"))


@app.get("/me/listings")
@login_required
def my_listings():
    user = current_user()
    assert user is not None
    db = get_db()
    listings = db.execute(
        "SELECT * FROM listings WHERE user_id = ? ORDER BY created_at DESC",
        (int(user["id"]),),
    ).fetchall()
    return render_template("my_listings.html", listings=listings)


def _get_listing_owned_or_404(listing_id: int):
    user = current_user()
    assert user is not None
    db = get_db()
    listing = db.execute(
        "SELECT * FROM listings WHERE id = ? AND user_id = ?",
        (listing_id, int(user["id"])),
    ).fetchone()
    if not listing:
        abort(404)
    return listing


@app.get("/listings/<int:listing_id>/edit")
@login_required
def edit_listing(listing_id: int):
    listing = _get_listing_owned_or_404(listing_id)
    return render_template("edit_listing.html", listing=listing)


@app.post("/listings/<int:listing_id>/edit")
@login_required
def edit_listing_post(listing_id: int):
    listing = _get_listing_owned_or_404(listing_id)

    title = (request.form.get("title") or "").strip()
    price_s = (request.form.get("price") or "").strip()
    location = (request.form.get("location") or "").strip()
    description = (request.form.get("description") or "").strip()

    errors = []
    if len(title) < 5:
        errors.append("Title must be at least 5 characters.")
    if len(location) < 2:
        errors.append("Location is required.")
    if len(description) < 20:
        errors.append("Description must be at least 20 characters.")

    try:
        price_cents = parse_price_to_cents(price_s)
    except ValueError as e:
        errors.append(str(e))
        price_cents = int(listing["price_cents"])

    if errors:
        for e in errors:
            flash(e, "danger")
        return redirect(url_for("edit_listing", listing_id=listing_id))

    db = get_db()
    db.execute(
        """
        UPDATE listings
        SET title = ?, price_cents = ?, location = ?, description = ?, updated_at = ?
        WHERE id = ? AND user_id = ?
        """,
        (title, price_cents, location, description, utc_now_iso(), listing_id, int(listing["user_id"])),
    )
    db.commit()
    flash("Listing updated.", "success")
    return redirect(url_for("my_listings"))


@app.post("/listings/<int:listing_id>/mark-sold")
@login_required
def mark_sold(listing_id: int):
    listing = _get_listing_owned_or_404(listing_id)
    if listing["status"] == "SOLD":
        flash("Listing is already marked SOLD.", "info")
        return redirect(url_for("my_listings"))

    db = get_db()
    db.execute(
        "UPDATE listings SET status = 'SOLD', updated_at = ? WHERE id = ? AND user_id = ?",
        (utc_now_iso(), listing_id, int(listing["user_id"])),
    )
    db.commit()
    flash("Listing marked as SOLD.", "success")
    return redirect(url_for("my_listings"))


@app.post("/listings/<int:listing_id>/delete")
@login_required
def delete_listing(listing_id: int):
    listing = _get_listing_owned_or_404(listing_id)

    db = get_db()
    db.execute("DELETE FROM listings WHERE id = ? AND user_id = ?", (listing_id, int(listing["user_id"])))
    db.commit()

    flash("Listing deleted.", "success")
    return redirect(url_for("my_listings"))

def cart_ids():
    return [int(x) for x in session.get("cart", [])]

def cart_add(car_id: int):
    ids = cart_ids()
    if car_id not in ids:
        ids.append(car_id)
    session["cart"] = ids

def cart_clear():
    session["cart"] = []

def load_cart_items(conn):
    ids = cart_ids()
    if not ids:
        return []
    q = ",".join(["?"] * len(ids))
    rows = conn.execute(f"SELECT id, title, price, sold FROM cars WHERE id IN ({q})", ids).fetchall()
    by_id = {r["id"]: r for r in rows}
    return [by_id[i] for i in ids if i in by_id]

# ---- dummy payment ----
def dummy_charge(card_number: str, exp_mm: str, exp_yy: str, cvc: str) -> str:
    if not flag("payment.dummy.enabled", default=True):
        raise ValueError("Dummy payments disabled")
    digits = "".join(ch for ch in (card_number or "") if ch.isdigit())
    if digits != "4242424242424242":
        raise ValueError("Card declined (dummy gateway)")
    if not (exp_mm and exp_yy and cvc):
        raise ValueError("Missing card details")
    return f"DUMMY-{uuid.uuid4().hex[:12].upper()}"

# ---- routes ----
@app.post("/cart/add/<int:car_id>")
def add_to_cart(car_id):
    if not flag("cart.enabled", default=True):
        abort(404)

    conn = get_db()
    car = conn.execute("SELECT id, sold FROM cars WHERE id = ?", (car_id,)).fetchone()
    if not car:
        abort(404)
    if int(car["sold"]) == 1:
        flash("Car already sold.")
        return redirect(request.referrer or url_for("view_cart"))

    cart_add(car_id)
    flash("Added to cart.")
    return redirect(request.referrer or url_for("view_cart"))

@app.get("/cart")
def view_cart():
    if not flag("cart.enabled", default=True):
        abort(404)

    conn = get_db()
    items = load_cart_items(conn)
    total_cents = sum(money_to_cents(i["price"]) for i in items if int(i["sold"]) == 0)
    return render_template(
        "cart.html",
        items=items,
        total_cents=total_cents,
        CHECKOUT_ENABLED=flag("checkout.enabled", default=True),
    )

@app.get("/checkout")
def checkout():
    if not (flag("cart.enabled", True) and flag("checkout.enabled", True)):
        abort(404)

    conn = get_db()
    items = load_cart_items(conn)
    if not items:
        flash("Cart is empty.")
        return redirect(url_for("view_cart"))
    if any(int(i["sold"]) == 1 for i in items):
        flash("One or more cars were sold. Please refresh cart.")
        return redirect(url_for("view_cart"))

    total_cents = sum(money_to_cents(i["price"]) for i in items)
    return render_template("checkout.html", items=items, total_cents=total_cents)

@app.post("/pay")
def pay():
    if not (flag("cart.enabled", True) and flag("checkout.enabled", True)):
        abort(404)

    card_number = request.form.get("card_number", "")
    exp_mm = request.form.get("exp_mm", "")
    exp_yy = request.form.get("exp_yy", "")
    cvc = request.form.get("cvc", "")

    conn = get_db()
    items = load_cart_items(conn)
    if not items:
        flash("Cart is empty.")
        return redirect(url_for("view_cart"))

    try:
        conn.execute("BEGIN IMMEDIATE")

        ids = [i["id"] for i in items]
        q = ",".join(["?"] * len(ids))

        available = conn.execute(
            f"SELECT COUNT(*) AS c FROM cars WHERE id IN ({q}) AND sold = 0",
            ids,
        ).fetchone()["c"]
        if available != len(ids):
            conn.execute("ROLLBACK")
            flash("Some cars were just sold. Try again.")
            return redirect(url_for("view_cart"))

        payment_ref = dummy_charge(card_number, exp_mm, exp_yy, cvc)
        total_cents = sum(money_to_cents(i["price"]) for i in items)
        now = datetime.now(timezone.utc).isoformat()

        cur = conn.execute(
            "INSERT INTO purchases (created_at, total_amount_cents, payment_ref) VALUES (?, ?, ?)",
            (now, total_cents, payment_ref),
        )
        purchase_id = cur.lastrowid

        for i in items:
            conn.execute(
                "INSERT INTO purchase_items (purchase_id, car_id, price_cents) VALUES (?, ?, ?)",
                (purchase_id, i["id"], money_to_cents(i["price"])),
            )

        conn.execute(f"UPDATE cars SET sold = 1, sold_at = ? WHERE id IN ({q})", (now, *ids))

        conn.commit()
        cart_clear()
        return redirect(url_for("purchase_success", purchase_id=purchase_id))
    except Exception as e:
        try:
            conn.execute("ROLLBACK")
        except Exception:
            pass
        flash(str(e))
        return redirect(url_for("checkout"))

@app.get("/purchase/<int:purchase_id>/success")
def purchase_success(purchase_id):
    conn = get_db()
    p = conn.execute("SELECT * FROM purchases WHERE id = ?", (purchase_id,)).fetchone()
    if not p:
        abort(404)
    items = conn.execute(
        """SELECT c.id, c.title, pi.price_cents
           FROM purchase_items pi
           JOIN cars c ON c.id = pi.car_id
           WHERE pi.purchase_id = ?""",
        (purchase_id,),
    ).fetchall()
    return render_template("success.html", purchase=p, items=items)
# ----------------------------
# Run
# ----------------------------
if __name__ == "__main__":
    # dev server
    app.run(host="0.0.0.0", port=5000, debug=False)

